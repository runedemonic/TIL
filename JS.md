# 변수

변수는 프로그램을 작성하는 데 가장 중요한 요소이다.

프로그램은 알고리즘을 사용하여 문제를 해결하는데, 알고리즘을 표현하기 위해서는 대부분 변수를 필수로 사용해야한다.

변수를 선언해보자.

## ① 변수

변수는 값을 담기 위해 이름을 붙인 상자이다.

변수 값을 알고리즘에 따라서 변화시켜서 프로그램이 의도한 목적을 달성한다.

## ② 변수 선언

변수를 사용하려먼, 변수를 선언해야한다.

```jsx
var sum;
```

코드를 통해서 sum 이라는 변수가 생성된다.

여기에서 `var` 는 자바스크립트 키워드로 변수를 선언하기 위한 **선언자**이다.

`sum` 부분은 **변수이름**이라고 부르며, 이 변수 이름을 이용해 변수 값을 읽거나 쓸 수 있다.

C 와 Java 에서는 변수타입이 다양하지만, 자바스크립트에는 변수 타입이 없기 때문에, `var` 하나 뿐이다.

`,` 를 활용하면 여러 개를 한 개의 문장으로 선언할 수 있다.

```jsx
var sum, a;
```

변수를 선언하기만 하면 변수 안에는 정의되지 않았음을 보여주는 undefined라는 값이 들어간다.

```jsx
var x;
console.log(x); // undefined
```

`=` 대입 연산자를 통해서, 변수에 대한 값을 대입할 수 있다.

```jsx
x = 2;
var x = 5; 

var a = 1, b = 2, c = 3;
```

변수를 여러 개 선언하고 초깃값 설정을 쉼표로 구분하여 한 문장만 사용해서 표현할 수도 있다.

## ③ 변수 선언 생략

var 문으로 선언하지 않은 변수 값을 읽으려고 하면 참조 오류가 발생한다.

```jsx
console.log(x); // ReferenceError : x is not defined
```

변수를 선언하지 않는 상태에서 값을 대입하면 자바스크립트 엔진이 그 변수를 자동으로 전역 변수로 선언한다.

변수를 선언하지 않고, 변수를 사용하는 행위는 버그의 원인이 될 수 있다.

>   변수는 반드시 선언하고 사용해야한다.



## ④ 변수 끌어올림과 변수 중복 선언

작성한 순서에 따라 윗줄부터 차례대로 실행된다.

변수 선언은 이 원칙을 따르지 않는다.

```jsx
console.log(x); // undefined
var x;
```

중간에서 변수를 선언해도, 변수가 프로그램 첫머리에 선언된 것처럼 다른 문장 앞에 생성되기 떄문이다. 이를 "hoisting(호이스팅)"이라고 한다.

```jsx
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```

변수가 선언되고, 이후의 작업에 영향을 미친다.

>  변수 선언의 끌어올림('hoisting')은 자바스크립트만의 고유한 특징이다.



사용자가 이해하기 쉬운 프로그램을 만들기 위해서 변수 선언부를 반드시 프로그램의 시작부분에 위치시켜야한다.

## ⑤ 변수의 명명 규칙

변수 / 함수 / 라벨 이름 등 사용자가 정의하는 이름을 **식별자**라고 한다.

식별자는 해당 규칙을 따라야한다.

- 알파벳, 숫자, 밑줄, 달러 기호 등의 문자를 사용할 수 있다.
- 첫 글자는 숫자로 사용할 수 없다.
- 예약어를 식별자로 사용할 수 없다.

> * key    sum1    name    $width    sum_all    sumAll     newValue → 사용 가능
>   1st (첫 글자가 숫자)    sum-all(하이픈은 사용할 수 없음)       new(예약어) → 사용 불가





### 캐멀 표기법

두 번째 이후 단어의 첫 글자를 대문자로 표기하고, 나머지는 소문자로 표기한다.

ex) newName     createLifeGame

### 파스칼 표기법

각 단어의 첫 글자를 대문자로 표기하고 나머지는 소문자로 표기한다.

ex) NewName    CreateLifeGame

### 밑줄 표기법

모든 단어를 소문자로 표기하고 단어와 단어를 밑줄로 구분한다.

ex) new_name    create__life_game

## ⑥ 예약어

자바스크립트 언어 사양에서 사용하는 특수한 키워드를 말한다.

ECMAScript 6의 예약어이다.

![예약어](https://raw.githubusercontent.com/runedemonic/TIL/master/img/Untitled.png)

# 데이터 타입

프로그래밍 언어의 기본적인 구성 요소이다.

데이터 타입과 관련된 기본적인 사항과 데이터 타입의 종류 중 하나인 원시타입을 배운다.

## ① 데이터 타입과 변수의 동적 타이핑

데이터 타입은 숫자나 문자열처럼 변수에 저장하는 데이터 종류를 뜻한다.

변수에 타입이 있는 언어를 가리켜 `정적 타입 언어` 라고 부른다.

하지만, 자바스크립트는 변수에 타입이 없기 때문에, 변수에 모든 타입의 데이터를 저장할 수 있다.

```jsx
var pi = 3.14;
console.log(pi); // 3.14
pi = '원주율';
console.log(pi); // 원주율
```

3.14 라는 숫자를 대입했지만, 그 후에도 원주율이라는 문자열을 대입할 수 있다.

이처럼 변수에 저장된 데이터 타입을 동적으로 바꿀 수 있는 언어를 가리켜 `동적 타입 언어` 라고 부른다.

그렇기에, 프로그램을 실행할 때 발생하는 타입 변환에 주의하여 ***변수에 어떤 타입의 데이터가 저장되는지***  잘 확인해야한다.

## ② 데이터 타입의 종류

자바스크립트 타입은, `원시 타입`과 `객체 타입`이다.

원시 타입 = 숫자, 문자열, 논리값, 특수한 값(null, undefined)과 심벌(Symbol).

원시 데이터는 데이터를 구성하는 가장 기본적인 요소로 불변 값(값을 바꿀 수 없는 데이터)으로 정의되어있다.

객체 = 원시 타입에 속하지 않은 자바스크립트의 값. 여러 개가 모여서 만들어진 복합 데이터 타입이다.

객체 타입의 값을 변수에 대입하면 변수에는 그 객체에 대한 참조가 할당된다. 배열, 함수, 정규 표현식과 같은 다양한 요소가 객체이다.

## ③ 숫자

프로그램에 직접 작성할 수 있는 상수 값을 `리터럴` 이라고 한다. 숫자를 표현하는 리터럴에는 정수 리터럴과 부동소수점 리터럴이 있다.

[숫자 리터럴](https://www.notion.so/dc0d8d6ebe4341a9b65d333eabb97c85)

숫자 앞에 0을 붙여서 8진수 정수 리터럴을 표기하는 방법이 있지만, 자바스크립트 엔진에서는 이 표기법을 지원하지 않는다.

특별한 숫자를 표현하기 위한 문자열이 정의되어있다. 모두 읽기 전용이기 때문에 수정할 수 없다.

[특수한 값](https://www.notion.so/47dac88ffa04487499829690da04aaf3)

## ④ 문자열

문자열 리터럴은 작은따옴표(`'`) 나 큰따옴표(`"`) 를 문자열의 앞뒤에 붙어서 표현한다.

> 'Without haste, but without rest.' "서두르지 말라. 그러나 쉬지도 말라." "" '3.14'

"" 는 아무것도 포함하지 않은 문자열이라고 하여, 빈 문자열이라고 한다.

문자열 안에 작은따옴표가 포함되었다면, 큰 따옴표로 묶어서 표현할 수 있고, 큰따옴표가 포함되었다면 작은따옴표로 묶어서 표현할 수 있다.

> "I'm going to learn Javascript."

자바스크립트를 HTML 요소에 끼워 넣을 때는 자바스크립트 프로그램을 문자열로 작성한다.

> <input type="button" value="Click" onclick="alert('Thanks!')">

HTML 코드에는 큰따옴표를 사용하고 자바스크립트 코드에는 작은따옴표를 사용하여 HTML과 자바스크립트에서 사용하는 따옴표를 구분해야 좋다.

이러한 특수문자는 이스케이프 시퀀스로 표현해야한다.

이스케이스 시퀀스는 역슬래시(`\\`) 뒤에 특정 문자를 뜻하는 기호를 표기한 형태이다. 작은 따옴표로 묶은 문자열 안에 넣을 때는 다음과 같이 이스케이프 시퀀스로 바꾸어 넣는다.

> 'I\'m going to learn Javascript.'

[이스케이프 시퀀스 목록](https://www.notion.so/e356c8e79a864863b0d55747bab14b91)

## ⑤ 논리값

논리값은 조건식이 참인지 거짓인지 표현하기 위해 사용하는 값이다.

논리값에는 true 와 false 두 가지 종류가 있다. `true`는 참을 뜻하고, `false`는 거짓을 뜻한다.

> x == 2

x값이 2와 같은지 판별하는 조건식이다. 이 코드에서 `==` 은 관계 연산자이다. x의 값이 2일 때는 true / 그렇지 않을 때에는 false 이다.

주로 논리값을 제어구문(if/else문, while문, do/while문, for 문) 에 사용한다.

## ⑥ 특수한 값

**값이 없음**을 표현하기 위한 특수한 값에는 `null` 과 `undefined`가 있다.

undefined는 정의되지 않은 상태를 뜻하며 다음 값이 undefined가 된다.

- 값을 아직 할당하지 않은 변수의 값
- 없는 객체의 프로퍼티를 읽으려고 시도했을 때의 값
- 없는 배열의 요소를 읽으려고 시도했을 때의 값
- 아무것도 반환하지 않은 함수가 반환하는 값
- 함수를 호출했을 때 전달받지 못한 인수의 값

`null` 은 **아무것도 없음**을 값으로 표현한 리터럴이다.

null은 주로 프로그램에서 무언가를 검색했지만 찾지 못했을 때, 아무것도 없음을 전달하기 위한 값으로 사용된다.

따라서, 값을 읽을 때 그 값이 null 인지 아닌지 확인해야 하는 상황이 자주 발생한다.







# 함수의 기초

함수는 자바스크립트 프로그래밍 언어를 규정하는 가장 중요한 구성요소이다.

## ① 함수

수학에서는 함수는 주어진 입력 값 x 에 대해 출력 값 y 를 대응시키는 규칙이다.

f

x ——> y =f(x)

함수 이름을 f 라고 했을 때, 함수 값인 y는 f(x) 라고 쓴다.

자바스크립트에서 함수는 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 둔 것이다.

자바스크립트에서는 함수의 입력 값을 **인수**라고 부르고, 출력값을 **반환값**이라고 부른다.

## ② 함수 선언문으로 함수 정의하기

함수는 function 키워드를 사용해서 정의한다.

예를 들어 square 함수를 정의하는 코드이다.

```jsx
function square(x) {return x * x;}
```

이 함수는 인수의 제곱을 계산해서 반환한다.

소괄호에 있는 x가 인수고 중괄호 안에 있는 코드가 함수를 실행하는 작업이다.

함수가 처리하는 내용은 다음의 return 문 뿐이다.

> return 문 다음에는 줄 바꿈 문자를 넣지 말 것
>
> return 과 값 사이에 줄 바꿈 문자를 넣으면 자바스크립트 엔진이 세미콜론을 자동으로 추가해서 해석한다.
>
> return x * x;
>
> 자바스크립트는 이 코드를 다음과 같이 해석한다.
>
> return; x * x;
>
> 즉 값이 없는 return 문으로 해석한다.



return 문이 실행되면 제어권이 함수를 호출한 코드가 되돌아가고,  return 문에 저장된 값은 함수의 반환값이 된다.

## ③ 함수 이름

변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있다.

그러나 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야한다. 함수에 이름을 잘 붙이면 그 함수가 어떤 일을 하는지 주석을 보지 않고도 파악할 수 있으므로 프로그램의 가독성과 유지 보수성이 크게 높아진다.

함수 이름은 일반적으로 동사 또는 동사로 시작되는 어휘로 만든다.

```jsx
function saveImage(img){...}
function getMousePosition(event){...}
function load_file(){...}
```

## ④ 함수 호출

함수를 호출하려면 함수 이름 뒤에 소괄호로 인수를 묶어 입력한다.

```jsx
square(3) // 9
```

그러면 인수로 넘긴 3이 함수 정의문의 인수x 로 전달되고 중괄호 안에 작성된 코드를 실행한다.

결과적으로 return 문의 값이 9인 함수의 반환값이 된다.

이때 함수를 호출할 때 전달하는 값을 **인수**(argument), 함수 정의문의 인수를 **인자(parameter)**라고 부른다.

## ⑤ 인수

함수는 인수를 여러 개 받을 수 있다.

인수가 여러 개라면 인수와 인수를 쉼표로 구분한다.

예를 들어, dist는 두 점 사이의 거리를 구하는 함수이다. 이때 전달하는 인수 p와 q는 좌표평면의 점 하나를 표현하는 객체이며, 각각의 객체는 {x:1, y:2} 라는 구조를 가지고 있다.

```jsx
function dist(p,q) {
	var dx = q.x - p.x;
	var dy = q.y - p.y;
	return Math.sqrt(dx*dx+dy*dy);
}
```

`Math.sqrt` 는 제곱근을 구하는 함수이다.

함수 dist 를 사용하여 두 점 사이의 거리를 구하는 코드는 다음과 같다.

```jsx
var p1 = {x:1, y:1};
var p2 = {x:4, y:5};
var d = dist(p1,p2);
```

인수를 받지 않는 함수도 정의할 수 있다.

```jsx
var bark = function() {console.log("Bow-wow");};
bark(); // Bow-wow
```

bark 함수에는 인수도 없고 return 문도 없다. return 문이 실행되지 않은 상태에서 제어권이 함수를 호출한 코드로 되돌아가면 함수의 반환값이 undefined가 된다.

```jsx
console.log(bark()); // undefined
```

## ⑥ 함수의 실행 흐름

일반적인 함수의 실행흐름은 다음과 같다.

- 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다.
- 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다.
- return 문이 실행되면 호출한 코드로 돌아간다. return 문의 값은 함수의 반환값이 된다.
- return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 undefined 가 함수의 반환값이 된다.

## ⑦ 함수 선언문의 끌어올림

자바스크립트 엔진은 변수 선언문과 마찬가지로 함수 선언문을 프로그램의 첫머리로 끌어올린다.

함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있다.

예를 들어 함수를 정의하기 전에 함수를 실행하는 코드를 작성해도 문제없이 동작한다.

```jsx
console.log(square(5)); // 25
function square(x) {return x*x;}
```

## ⑧ 값으로서의 함수

자바스크립트에서 함수는 객체이다. 함수 선언문으로 함수를 선언하면, 내부적으로는 그 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고 그 변수에 함수 객체의 참조가 저장된다.

suqare ————> function(x) {return x*x;}

이 변수 값을 다른 변수에 할당하면 그 변수의 이름으로 함수를 실행할 수 있다.

```jsx
var sq = square;
console.log(sq(5)); // 25
```

## ⑨ 참조에 의한 호출과 값에 의한 호출

함수는 원시 값을 인수로 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작한다.

먼저 인수가 원시 값일 때 어떻게 동작하는지 예제를 살펴보자.

```jsx
function add1(x) {return x = x + 1;}
var a = 3;
var b = add1(a);
console.log("a = " + a + ", b = " + b ); // a=3 , b=4
```

add1은 전달받은 인수에 1을 더하여 반환하는 함수이다. 이 함수가 호출될 때 변수 a의 복사본이 인자 x에 할당된다.

즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달된다.

이를 가리켜 **값의 전달**이라고 부른다. 이 때 변수 a와 변수 x는 다른 영역의 메모리에 위치한 별개의 변수이다.

따라서, x값을 바꾸더라도 a 값을 바뀌지 않는다.

a = 3  ——> x = 3 (값이 복사본을 대입)

인수가 객체일 때 어떻게 동작하는지 예제를 살펴보자.

```jsx
function add1(p) {p.x = p.x + 1; p.y = p.y +1; return p;}
var a = {x:3 , y:4};
var b = add1(a);
console.log(a,b); // Object {x=4, y=5} Object {x=4, y=5}
```

add1 함수는 2차원 좌표의 각 성분에 1을 더한 좌표를 반환하는 함수이다.

함수가 호출될 때 변수 a의 복사본이 인자 p에 할당된다.

여기까지는 원시 값을 인수로 넘겻을 때와 동일하게 동작한다.

그러나 이전과 다르게 변수 a에 객체 {x:3, y:4} 의 참조가 저장되어 있으며, 이 참조 값을 인자p에 대입한다.

즉, 인수로 객체를 넘겼을 때 전달되는 값은 참조값이다. 따라서 함수 안에서 p.x와 p.y 를 수정하는 행위는 a.x와 a.y를 수정하는 행위와 같다.

이처럼 함수의 인수로 객체를 넘기면 함수 안에서 원래의 객체를 바꿀 수 있다.

### 인수 여러개를 우아하게 전달하는 방법 (elegant way)

함수에 넘겨야 하는 인수 개수가 많아지면 문제들이 발생한다.

- 인수의 순서를 착각하기 쉽다.
- 함수가 받는 인수 개수를 바꾸면 함수의 호출 방법이 바뀌므로 프로그램 전체를 수정해야한다.

객체의 프로퍼티에 인수를 담아서 넘기면 이러한 문제를 우아하게 해결할 수 있다.

```jsx
function setBallProperties(x,y,vx,vy,radius){ ... }
...
setBallProperties(0,0,10,15,5);
```

이 함수의 인수를 다음과 같이 객체의 프로퍼티에 담아서 함수에 넘기도록 고쳐보자.

```jsx
var parameters = {
	x:0,
	y:0,
	vx:10,
	vy:15,
	radius:5
}
```

이렇게 수정하면 함수의 인수를 하나만 받도록 할 수 있다.

```jsx
function setBallProperties(params){ ... }
...
setBallProperties(parameters);
```

이 때 함수 안에서 프로퍼티를 읽는 코드는 `params.vx` 처럼 표현하면 되므로, 인수 순서가 바뀌는 문제가 발생하지 않는다. 또한 전달하는 인수를 추가하는 경우에도 프로퍼티만 추가하면 되므로 함수를 호출하는 방법을 바꿀 필요가 없다.

```jsx
var parameters = {
	x:0,
	y:0,
	vx:10,
	vy:15,
	radius:5,
	color:"blue"
};
setBallProperties(parameters);
```

단 함수 안에서 객체의 프로퍼티를 수정하면 호출한 코드에 있는 인수 객체의 프로퍼티가 함께 바뀌므로 주의해야한다.

객체를 인수로 넘기면 함수에는 객체의 참조가 전달되기 떄문이다.

## ⑩ 변수의 유효 범위

### 전역 유효 범위와 지역 유효 범위

변수에 접근할 수 있는 범위를 그 변수의 유효 범위(Scope)라고 부른다.

유효 범위를 결정하는 두 가지가 있는데, 하나는 프로그램의 구문으로 유효범위를 정하는 **어휘적 범위**. 프로그램 실행 중에 유효 범위를 정하는 **동적 범위**이다.

C나 JAVA 같은 대다수의 프로그래밍 언어와 마찬가지로 자바스크립트도 어휘적 범위를 채택하고 있다.

자바스크립트 변수는 유효 범위에 따라서 두 가지로 나뉜다. 하나는 **전역 변수**고, 하나는 **지역 변수**이다.

전역변수는 함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램이다.

지역변수는 함수안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부이다.

```jsx
var a = "global";
function f(){
	var b = "local";
	console.log(a); // "global"
	return b;
}
f();
console.log(b); // b is not defined
```

변수 a는 **전역 변수**이고, 함수 안에 있는 변수b는 **지역 변수**이다.

a는 유효 범위가 전체 프로그램이기 때문에 함수 f 안에서도 유효하지만,

b는 유효 범위가 함수 내에서만 유효하기 때문에, 함수 밖에서 호출을 하면 참조 오류가 발생한다.

### 변수의 충돌

변수에 유효 범위가 있는 이유는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌되지 않도록 하기 위해서이다.

다른 함수 내부에서 선언된 각각의 지역 변수는 모두 선언된 함수 내부에서만 유효하므로 이름이 같아도 충돌하지 않는다.

덕분에 함수 안에서 변수 이름을 지을 때는 다른 함수 안에서 사용하는 변수 이름까지 신경쓸 필요가 없다.

하지만, 전역 변수 이름과 지역 변수이름이 같아지면 두 변수가 충돌한다. 이때는 전역 변수를 숨기고 지역변수를 사용하게 된다.

```jsx
var a = "global";
function f(){
	var a = "local";
	console.log(a); // "local"
	return a;
}
f();
console.log(a); // "global"
```

두 변수의 이름은 같지만, 다른 위치의 메모리에 있는 별개의 변수이다.

지역 변수 a의 유효 범위안에서는 전역 변수 a는 숨겨진다.

따라서 첫 번째 console.log(a) 의 출력은 local 이 된다.

한편 함수 바깥은 지역 변수 a의 유효범위를 벗어나므로 두 번째 console.log(a)의 값은 global이 된다.

### 함수 안에서의 변수 선언과 변수 끌어올림

함수 안에서 선언된 지역 변수의 유효범위는 함수 전체이다.

함수 중간 부분에서 변수를 선언하더라도 함수 첫머리에서 선언된 것처럼 함수 안의 다른 문장보다 먼저 생성된다.

즉, 자바스크립트 엔진은 함수 안의 변수 선언부를 함수의 첫 머리로 끌어올린다.

```jsx
function f(){
	console.log(a); // undefined
	var a = "local";
	console.log(a); // local
	return a;
}
```

### 함수 안에서의 변수 선언 생략

변수를 선언하지 않은 상태에서 값을 대입하면 전역 변수로 선언된다.

이 현상은 함수 바깥에서 발생하지만 함수 안에서도 발생한다.

```jsx
function f() {
	a = "local";
	console.log(a); // local
	return a;
}
f();
console.log(a); // local
```

변수 a는 함수 f 의 지역 변수처럼 보이지만,  var로 선언하지 않았기 때문에 실제로는 전역변수이다.

따라서 프로그램의 어느 위치에서도 사용할 수 있다.

## ⑪ 블록 유효 범위 : let 과 const

변수의 유효 범위와 밀접한 관계가 있는 let 과 const 선언자도 함께 살펴보자.

let 과 const 는 ECMAScript 6 부터 추가된 변수 선언자로 모두가 "블록 유효 범위"를 갖는 변수를 선언헌다.

블록 유효 범위를 가진 변수는 중괄호 안에서만 유효하다.

`let` 은 변수를 선언하고  `const`는 한 번만 할당할 수 있는 상수를 선언한다.

### let 선언자

let 문은 블록 유효 범위를 갖는 지역변수를 선언한다.

사용법은 var와 같다.

```jsx
let x;
```

변수가 여러 개 일때는 쉼표로 구분하여 동시에 선언할 수 있다.

```jsx
let a,b,c;
```

변수를 선언하면서 초깃값을 설정할 수 있다.

```jsx
let x=5,y=7;
```

var로 선언한 변수와 let으로 선언한 변수의 가장 큰 차이점은 let 으로 선언한 변수의 유효 범위가 블록안이라는 점이다.

```jsx
let x ="outer x";
{
	let x = "inner x";
	let y = "inner y";
	console.log(x); // inner x
	console.log(y); // inner y
}
console.log(x); // outer x
console.log(y); // y is not defined
```

중괄호 바깥에 있는  변수 x의 유효 범위는 전체 프로그램이며, 안에 있는 변수x의 유효 범위는 중괄호 안쪽이다.

y의 유효 범위는 중괄호 안이기때문에 밖에서 호출하는 것은 참조오류가 발생한다.

자바스크립트 엔진은 var문과는 달리 let문으로 선언한 변수를 끌어올리지 않는다.

```jsx
console.log(x); // x is not defined
let x = 5;
```

또한 let문으로 똑같은 이름을 가진 변수를 선언하면 문법 오류가 발생한다.

```jsx
let x;
let x; // SyntaxError
```

### const 선언자

const 문은 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수를 선언한다.

const 로 선언한 상수는 let 문으로 선언한 변수처럼 동작한다.

단 , 반드시 초기화해야한다는 차이점이있다.

```jsx
const c = 2;
```

const 문으로 선언한 변수에 다시 대입을 시도하면 타입 오류가 발생한다.

```jsx
c = 5; // TypeError
```

const 문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열인 경우네는 프로퍼티 또는 프로퍼티 값을 수정할 수 있다.

```jsx
const origin = {x:1,y:2};
origin.x = 3;
console.log(origin); // Object {x:3,y:2}
```

## ⑫ 함수 리터럴로 함수 정의하기

함수는 함수 리터럴로도 정의할 수 있다.

```jsx
var square = function(x) {return x*x;};
```

function(x) {...} 부분이 함수 리터럴이다.

함수 리터럴은 이름이 없는 함수이므로 **익명 함수** 또는 **무명 함수**라고도 부른다.

함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만, 함수 리터럴을 사용할 때에는 끝에 반드시 세미콜론을 붙여야한다.

함수 리터럴로 정의한 함수의 사용법에 대해서 알아보자.

square(5)라고 작성하면 함수를 실행할 수 있다.

함수 리터럴과 함수 선언문이 모두 내부적으로 square변수에 함수 객체의 참조를 저장하기 때문이다.

한 가지 차이점은, 자바스크립트 엔진이 함수 선언문으로 정의한 함수는 끌어올리지만 함수 리터럴로 작성한 함수는 끌어올리지 않는다.

```jsx
console.log(square(3)); // square is not a function.
var square = function(x) {return x*x;};
```

익명 함수에도 이름을 붙일 수 있다.

```jsx
var square = function sq(x) {return x*x;};
```

sq라는 이름은 함수안에서만 유효하므로 함수 바깥에서는 sq 라는이름으로 함수를 호출할 수 없다.

## ⑬ 객체의 메서드

객체의 프로퍼티 중에서 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 메서드라고 부른다.

메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입한다.

```jsx
var circle = {
	center : {x:1.0,y:2.0},
	radius : 2.5,
	area : function(){
		return Math.PI * this.radius * this.radius;
	}
};
```

함수 객체 안에 적힌 this 는 그 함수를 메서드로 가지고 있는 객체를 가리킨다.

위 코드에서는 circle 을 가리키고 `this.radius` 가 `circle.radius` 이다.

```jsx
circle.area() // 19.634954084936208
```

메서드 또한 프로퍼티의 일종이므로 나중에 추가할 수 있다.

```jsx
circle.translate = function(a,b){
	this.center.x = this.center.x + a;
	this.center.y = this.center.y + b;
}
```

이를 실행하면 다음과 같은 결과가 나온다.

```jsx
circle.translate(1,2);
circle.center; // Object {x=2,y=4}
```

객체의 내부 데이터 상태를 바꾸는 용도로 사용된다.

> 메서드는 외부 호출에 반응하여 내부 데이터(프로퍼티 값)의 상태르 바꾼다.

이러한 객체를 기본 부품으로 삼아 프로그램을 만들어 가는 기법을 가르켜 **객체 지향 프로그래밍** 이라고 부른다.

## ⑭ 함수를 사용하면 얻을 수 있는 장점

### 재사용할 수 있다.

똑같은 작업을 여러 번 반복해야할 때, 그 작업을 하나로 모아서 함수 하나로 만들어두면 호출만으로 같은 작업을 여러 번 반복할 수 있다.

결과적으로 같은 코드를 여러 번 작성해야할 필요가 없어지므로, 프로그램이 간결해진다.

또한, 같은 알고리즘을 사용하지만, 시작값이 다른 처리를 인수 값만 바꿔 호출하도록 수정하면 함수를 하나만 만들어 쓸 수 있다.

### 만든 프로그램을 이해하기 쉽다.

함수를 사용하면 일정한 처리를 모아서 이름을 붙일 수 있다.

이는 함수 안에서 상세한 내용을 숨기는 효과가 있따.

따라서, 프로그램을 읽을 때, 프로그램의 큰 흐름을 쉽게 파악할 수 있다.

### 프로그램 수정이 간단해진다.

함수를 사용하지 않으면 똑같은 처리를 프로그램 곳곳에 작성해야한다.

처리 부분을 수정한다면 같은 작업을 여러 번 반복해야한다.

그러나 함수로 정리해 두면 해당 함수만 수정하면 되므로 수정이 간단해진다.

# 연산자

프로그래밍에는 `+` 나 `*` 등의 연산자를 사용하여 다양한 계산을 한다.

각 연산자를 배우기 전, 모든 연산자에 해당하는 공통사항을 배워보도록 한다.

## ① 표현식과 연산자

표현식이란, 결과적으로 어떤 값으로 평가되는 것이다.

표현식의 값과 변수, 함수 등의 값을 바탕으로 식의 값을 계산하는 행위를 말하며, 가장 간단한 표현식은 숫자, 문자열, 논리값 등의 원시 값(Primitive values)이다.

>  3.14   , "hello"  ,  true ,   false , null



변수 , 프로퍼티, 배열요소, 함수 호출, 메서드 호출도 표현식이다.

>  sum , circle.radius , a[3] , square(5) , card.getSum()



연산자를 활용하면 표현식을 조합해서 더욱 복잡한 표현식을 만들 수 있다.

```jsx
a + b
```

`+`부분이 연산자이고, a와b 를 피연산자라고 부른다.

`+` 연산자의 왼쪽과 오른쪽에는 피연산자가 총 두 개 있다. 이러한 연산자를 이항연산자라고 부른다.

연산자는 보통 피연산자의 개수에 따라서 단항 연산자 / 이항 연산자 / 삼항 연산자 로 분류된다.

표현식은 먼저 왼쪽 피연산자 값부터 순서대로 평가되고, 그 다음에 연산자로 계산이 시작된다.

(단, 일부 연산자에는 예외가 있다.)

즉, 변수  a 값이 2 이고, b값이 3일때, 앞의 표현식은 다음코드로 평가된 후에 `+` 연산자로 계산된다.

## ② 연산자의 우선순위

연산자가 여러 개 있을 때는 계산 순서에 따라 결과가 달라진다.

```jsx
2 + 3 * 4
```

그룹 연산자 `()` 를 사용해서 계산 순서를 명시적으로 지정한 결과를 살펴보자.

그룹 연산자를 사용하면, 그 안에 있는 표현식이 먼저 평가된다.

```jsx
2 + ( 3 * 4 )
```

연산자에는 우선순위가 정해져있고, 우선순위에 따라서 연산 순서가 정해진다.

## ③ 연산자 결합 법칙

연산은 연산자 우선순위에 따라 진행되지만, 우선순위가 같은 연산자가 나열되어 있다면, 연산 순서를 연산자 우선순위만으로는 결정할 수 없다.

```jsx
24 / 6 * 2
```

나누기 연산자와 곱하기 연산자가 같이 있는데, 왼쪽에서 오른쪽으로 결합하면 결과는 8이 나온다.

하지만, 오른쪽에서 왼쪽으로 결합하면, 값은 2 라는 값이 나온다.

연산자에는 왼쪽과 결합해서 연산할지 아니면, 오른쪽과 결합해서 연산할지를 결정하는 결합법칙이 정해져있다.

만약, 연산자의 우선순위가 같을 때에는 왼쪽에서 오른쪽으로 결합한다.

결과는 8 이 되는 것이다.

## ④ 연산자의 부수 효과

변수 값을 바꾸는 표현식은 일반적으로 "부수 효과가 있는 표현식"이라고 부른다.

대입 연산자 / 증가 연산자 / 감소 연산자 / delete 가 부수효과가 있는 연산자이다. 그 외에 나머지 연산자에는 부수효과가 없다.

------

# 산술 연산

사칙연산이나 나머지 값 등의 산술 연산을 하는 연산자 , 제곱근이나 삼각 함수 등의 수학 함수에 대해서 배워보자.

수치 계산 문제를 풀 때, 산술 연산이 꼭 필요하기 때문에 잘 알아두도록 한다.

## ① 산술 연산자

피연산자가 숫자인 연산자이다.

피연산자가 숫자가 아닐 때는 연산자가 피연산자 타입을 숫자 타입으로 바꿔서 연산한다.

연산 결과로는 숫자 값이 나오지만, 피연산자가 숫자로 바꿀 수 없는 값이거나 계산할 수 없을 때는 `NaN` 이 나온다.

### 산술 이항 연산자

`+` `-` 는 수학에서 사용하는 기호와 같지만, 곱하기는 `*` 나누기는 `/` , 나머지는 `%` 로 표기한다.

[산술 이항 연산자](https://www.notion.so/17948157b83b489cab5a9528d093e52c)

### ① 정수끼리 나누어도 결과가 부동소수점이 된다.

다른 프로그래밍 언어에서는 정수 / 정수를 하면 결과값이 정수지만, 자바스크립트에서는 부동 소수점이 된다.

```jsx
7 / 2  // 3.5
```

### ② 나머지 연산자 %의 피연산자는 부동소수점이다.

자바스크립트에서는 모든 부동소수점 a와 b의 부동소수점을 구할 수 있다.

즉, 부동소수점으로 a%b를 계산할 수 있다.

```jsx
15 % 4 // 3
5 % 1.5 // 0.5 
```

### ③ + 연산자는 피연산자 중 하나가 문자열이면 나머지 피연산자를 문자열로 만든다.

`+` 연산자는 피연산자가 숫자면 더하고, 문자열이면 연결한다.

피연산자 중 하나가 숫자고 다른 하나가 문자열이면 숫자를 문자열로 바꾸고 연결한다.

```jsx
1 + "2month" // 12month
```

### ④ 기타

계산할 수 없는 경우에는 NaN으로 평가한다.

산술 연산자의 피연산자가 true 이면, 1  /  false 와 null 이면, 0 으로 취급하고, undefined 이면, NaN으로 평가한다.

```jsx
0 / 0 // NaN (계산할 수 없음)
"one" * 1 //NaN (계산할 수 없음)
true + true // 2
1 + null // 1
1 + undefined // NaN (undefined -> NaN 으로 변경)
```

### 산술 단항 연산자

증가 연산자는 피연산자 값에 1을 더하고, 감소 연산자는 피연산자 값에 1을 뺀다.

모두가 부수 효과가 있는 연산자이며 피연산자는 좌변에 있어야한다.

[산술 단항 연산자](https://www.notion.so/07fa84909bd145ef8323127f3e337158)

>  좌변 값
> 좌변 값이란, 대입 연산자의 왼쪽에 둘 수 있는 표현식을 말한다. 자바스크립트에서는, 변수 / 객체의 프로퍼티 / 배열 요소를 좌변값으로 둘 수 있다.



증가 연산자와 감소 연산자는 피연사자 앞에 표기하는 '전위 표기법' 과 뒤에 표기하는 '후위 표기법'을 사용할 수 있다.

전위 표기법을 사용하느냐, 후위 표기법을 사용하느냐에 따라 피연산자를 평가하는 시점이 달라진다.

전위 표기법을 사용하면, 피연산자 값을 바꾼 다음에 피연산자플 평가한다.

후위 표기법을 사용하면, 피연산자 값을 평가한 다음, 피연산자 값을 바꾼다.

```jsx
a = 1; 
b = ++a; // b는 2가 되고, a는 2가 된다. (a에 1을 더하고, a를 b에 대입한다.)
c = a++ + 2; // c는 4가 되고, a는 3이 된다. (a + 2 를 c에 대입하고, a에 1을 더한다.)
```

증가 연산자 또는 감소 연산자를 연속으로 사용하면 참조 오류가 발생한다.

```jsx
(a++)++ // ReferenceError
```

### 산술 대입 연산자

대입 연산자와 산술 이항 연산자를 조합한 연산으로, 조금 더 간결하게 표기하는 것이다.

[산술 대입 연산자](https://www.notion.so/5078954958a9400280303aebac6d3e88)

```jsx
sum += data;  // sum = sum + data ;
```

## ② Math 객체의 프로퍼티

자바스크립트에서는 Math 객체의 프로퍼티와 메서드가 포함되어있다.

삼각 함수 sin 은 Math.sin 메서드로 계산할 수 있으며, cos 는 Math.cos 로 계산할 수 있다.

또한, 원주율은 Math.PI 프로퍼티에 담겨있다.

다음 코드는 원점에서 r 만큼 떨어져있고, x 축의 각도가 theta 인 x좌표와 y 좌표를 구하는 함수이다.

단, 삼각함수가 받는 인수가 라디안이라는 것을 주의한다.

```jsx
function polarToDescartes(r,theta){
	var angle = Math.PI * theta / 100;
	return {x: r*Math.cos(angle), y : r*Math.sin(angle)};
}
```

[Math 객체의 프로퍼티](https://www.notion.so/3580a1e1018e459680f763cb977c9e32)

[Math 객체의 메서드](https://www.notion.so/d879b80a64d146c5865e1d71ddb06dd4)

## ③ 부동소수점과 정확도 문제

산술연산을 할 때는 유효한 자릿수가 있으므로, 게산할 때 오차가 발생한다는 점을 항상 염두해둬야한다.

자바스크립트의 숫자는 IEEE754로 규정된 64비트 부동소수점이며. 이는 64자릿수의 2진수 부동소수점을 표현한다.

이 규격에서 가수 부분은 1.ddd...d 라고 표현되며, ddd.d 부분이 52비트를 차지한다.

즉, 가수 부분의 유효한 자릿수가 2진수 53자리이므로, 10진수의 자릿수는 약 16자리가 된다.

숫자를 자릿수가 정해진 부동소수점으로 표현하여 계산하면, 오차가 발생하는데 이를 **정확도 문제** 라고 한다.

예를 들어,  루트 100001 - 루트 100000 을 계산해보자.

```jsx
Math.sqrt(100001) = 316.2293471517152
Math.sqrt(100000) = 316.22776601683796
```

이 둘을 빼면, 0.0015181134877255863 가 나온다.

하지만, 수학적으로 정확히 계산하면 값은 다음과 같다.

```jsx
Math.sqrt(100001) - Math.sqrt(100000) = 0.00158134877256878 ...
```

결과를 보면 간단한 뺄셈도 유효 자릿수가 16자리에서 12자리 줄어든 것을 볼 수 있다.

일반적으로 값이 가까운 두 수를 뺄셈할 때, 정확도 문제가 발생한다. 이것을 **정밀도 손실**이라고 한다.

정밀도 손실을 피하려면 계산 과정을 다시 검토하여 크기가 비슷한 수의 뺄셈을 하도록 해야한다.

이처럼, 바꾸면 정밀도 손실을 피할 수 있다.

```jsx
1 / (Math.sqrt(100001) + Math.sqrt(100000))
```

10진수로는 딱 떨어지는 값도 계산 결과가 조금씩 어긋난다.

산술 연산을 내부적으로는 2진수로 연산하기 때문이다.

예를 들어, a = 0.16 이고 b = 0.2 일 때, a / b 값으로 0.0 을 기대한다. 하지만, 실제로는 0.799999999999 라는 값이 나온다.

따라서 다음과 같은 식의 결괏값은 기대가 달리 `false` 가 된다.

```jsx
a / b == 0.0 //false
```

숫자를 비교할 때는 오차가 있다는 걸 고려해야한다.

다음과 같이 수정하면 문제를 피할 수 있다.

```jsx
Math.abs(a/b - 0.8) < 1e-10
```